"""
Adapted from original code from Pat Walters.
Split a protein-ligand complex into protein and ligands and assign ligand bond
orders using SMILES strings from Ligand Export.

TODO: look at https://gist.github.com/PatWalters/c046fee2760e6894ed13e19b8c99193b as a replacement
"""

from functools import cache
from io import StringIO
from pathlib import Path
from warnings import warn

import pandas as pd

from rdkit import Chem
from rdkit.Chem import AllChem

import prody
import pypdb
import requests


LIGAND_EXPO_FILENAME = "Components-smiles-stereo-oe.smi"
LIGAND_EXPO_URL = f"http://ligand-expo.rcsb.org/dictionaries/{LIGAND_EXPO_FILENAME}"

@cache
def _read_ligand_expo():
    """
    Read Ligand Expo data, try to find a file called
    Components-smiles-stereo-oe.smi in the current directory.
    If you can't find the file, grab it from the RCSB (archived in gs://hx-brian 2023-06-11)
    :return: Ligand Expo as a dictionary with ligand id as the key
    """
    if not Path(LIGAND_EXPO_FILENAME).exists():
        with open(LIGAND_EXPO_FILENAME, 'wb') as out:
            resp = requests.get(LIGAND_EXPO_URL, allow_redirects=True, timeout=300)
            out.write(resp.content)

    df_lig = pd.read_csv(LIGAND_EXPO_FILENAME, sep="\t", header=None, names=["SMILES", "ID", "Name"])
    df_lig.set_index("ID", inplace=True)

    return df_lig.to_dict()


def _split_pdb_into_protein_and_ligand(pdb_name:str):
    """
    Split a protein-ligand pdb into protein and ligand components
    :param pdb_name:
    :return: protein, ligand
    """
    pdb = prody.parsePDB(pdb_name)
    protein_sel = pdb.select('protein')
    ligand_sel = pdb.select('not protein and not water')
    return protein_sel, ligand_sel


def _process_ligand(ligand, res_name, chain, ligand_smiles=None):
    """
    Add bond orders to a pdb ligand
    1. Select the ligand component with name "res_name"
    2. Get the corresponding SMILES from the Ligand Expo dictionary
    3. Create a template molecule from the SMILES in step 2
    4. Write the PDB file to a stream
    5. Read the stream into an RDKit molecule
    6. Assign the bond orders from the template from step 3

    :param ligand: ligand as generated by prody
    :param res_name: residue name of ligand to extract
    :return: molecule with bond orders assigned
    """

    expo_dict = _read_ligand_expo()

    output = StringIO()
    sub_mol = ligand.select(f"resname {res_name} and chain {chain}")
    print("sub_mol", sub_mol)
    if sub_mol is None:
        warn(f"sub_mol is None for {res_name}")
        return None, None

    if ligand_smiles is None:
        ligand_smiles = expo_dict['SMILES'][res_name]

    print("ligand_smiles", ligand_smiles)
    template = AllChem.MolFromSmiles(ligand_smiles)
    print("template", template)
    if template is None:
        print(f"template is None for {ligand_smiles}. Returning None.")
        return None, None

    prody.writePDBStream(output, sub_mol)
    pdb_string = output.getvalue()

    rd_mol = AllChem.MolFromPDBBlock(pdb_string)
    print("rd_mol", rd_mol)

    rd_mol_templated = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)

    return rd_mol_templated, ligand_smiles


def _process_ligand_alt(ligand, res_name, chain, ligand_smiles=None):
    """
    https://gist.github.com/PatWalters/c046fee2760e6894ed13e19b8c99193b
    Add bond orders to a pdb ligand
    1. Select the ligand component with name "res_name"
    2. Get the corresponding SMILES from pypdb
    3. Create a template molecule from the SMILES in step 2
    4. Write the PDB file to a stream
    5. Read the stream into an RDKit molecule
    6. Assign the bond orders from the template from step 3
    :param ligand: ligand as generated by prody
    :param res_name: residue name of ligand to extract
    :return: molecule with bond orders assigned
    """
    output = StringIO()
    sub_mol = ligand.select(f"resname {res_name} and chain {chain}")
    chem_desc = pypdb.describe_chemical(f"{res_name}")
    sub_smiles = chem_desc["describeHet"]["ligandInfo"]["ligand"]["smiles"]
    template = AllChem.MolFromSmiles(sub_smiles)
    prody.writePDBStream(output, sub_mol)
    pdb_string = output.getvalue()
    rd_mol = AllChem.MolFromPDBBlock(pdb_string)
    new_mol = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)
    return new_mol, sub_smiles


def _write_sel_to_pdb(protein, out_pdb_file:str) -> bool:
    """
    Write a prody protein to a pdb file
    :param protein: protein object from prody
    :param pdb_name: base name for the pdb file
    :return: None
    """
    prody.writePDB(out_pdb_file, protein)
    return out_pdb_file


def _write_mol_to_sdf(rd_mol, out_sdf_file:str) -> bool:
    """
    Write an RDKit molecule to an SD file
    :param rd_mol:
    :param pdb_name:
    :param res_name:
    :param out_sdf_name:
    :return: out_sdf_name
    """
    writer = Chem.SDWriter(out_sdf_file)
    writer.write(rd_mol)
    return out_sdf_file


def extract_ligand(pdb_name:str, ligand_name:str, ligand_chain:str, out_pdb_file:str,
                   out_sdf_file:str|None=None,
                   ligand_smiles:str|None=None) -> tuple[str, str, str]:
    """
    Read Ligand Expo data, split pdb into protein and ligands,
    write protein pdb, write ligand sdf files
    :param pdb_name: pdb filename or pdb id? FIXFIX
    :param ligand_name: ligand id within the pdb, one or multiple
    :param ligand_chain: ligand chain; necessary to avoid accidental ligand merging
    :out_pdb_name: pdb output
    :out_sdf_name: sdf output
    :ligand_smiles: ligand smiles
    :return:
    """
    print(pdb_name, ligand_name, ligand_chain, out_pdb_file, out_sdf_file, ligand_smiles)
    # ----------------------------
    # First write out protein part
    #
    protein_sel, ligand_sel = _split_pdb_into_protein_and_ligand(pdb_name)

    # optionally, write out the pdb with no ligands
    if out_pdb_file is not None:
        out_pdb_file = _write_sel_to_pdb(protein_sel, out_pdb_file)

    print("EXTRACT", pdb_name, ligand_name, ligand_chain)
    # ----------------------------
    # Then write out ligands
    #
    print("ligand_name", ligand_name)

    if out_sdf_file is None:
        out_sdf_file = Path(out_pdb_file).with_suffix('') + f"_{ligand_name}.sdf"

    print("ligand_smileses should be None", ligand_smiles)

    new_mol, new_mol_smiles = _process_ligand(ligand_sel, ligand_name, ligand_chain, ligand_smiles)
    if new_mol is None:
        raise ValueError(f"{ligand_name} molecule object is None")

    print("output res_name", new_mol, out_sdf_file)
    out_sdf_file = _write_mol_to_sdf(new_mol, out_sdf_file)

    print("returning ", out_pdb_file, out_sdf_file, new_mol_smiles)
    return out_pdb_file, out_sdf_file, new_mol_smiles


def extract_all_ligands(pdb_name, out_pdb_name):
    _, ligand_sel = _split_pdb_into_protein_and_ligand(pdb_name)
    all_ligand_names_chains = set(zip(ligand_sel.getResnames(), ligand_sel.getChids()))
    for ligand_name, ligand_chain in all_ligand_names_chains:
        _ = extract_ligand(pdb_name, ligand_name, ligand_chain, out_pdb_name)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Extract ligands from a PDB file.')
    parser.add_argument('pdb_id', type=str, help='PDB ID')
    parser.add_argument('ligand_names', type=str, help='Comma-delimited list of ligand names')
    parser.add_argument('--chains', type=str, default=None, help='Comma-delimited list of chains for each ligand')
    
    args = parser.parse_args()
    args_ligand_names = args.ligand_names.split(",")
    args_chains = args.chains.split(",") if args.chains is not None else None

    outputs = extract_ligands(args.pdb_id, args_ligand_names, args_chains)
    print(outputs)
